#include <iostream>
#include <string>
#include <vector>

#include <opencv2/core/core.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/xfeatures2d.hpp"

#include "DBoW3/DBoW3.h"

#include "icp.h"
#include "util.h"
#include "visual_odometry.h"

using namespace cv;
using namespace cv::xfeatures2d;
using namespace std;

/***************************************************
 * 本节演示了如何根据data/目录下的十张图训练字典
 * ************************************************/

// int main(int argc, char** argv)
// {
//   vector<pcl::PointCloud<pcl::PointXYZRGB>::Ptr> pcs;
//   vector<Mat> images, depths;
//   readConfig();
//   readData(pcs, images, depths);

//   cout << "detecting features ... " << endl;
//   Ptr<SIFT> detector = SIFT::create(1000);
//   vector<Mat> descriptors;
//   for (Mat& image : images)
//   {
//     vector<KeyPoint> keypoints;
//     Mat descriptor;
//     detector->detectAndCompute(image, Mat(), keypoints, descriptor);
//     descriptors.push_back(descriptor);
//   }

//   // create vocabulary
//   cout << "creating vocabulary ... " << endl;
//   DBoW3::Vocabulary vocab;
//   vocab.create(descriptors);
//   cout << "vocabulary info: " << vocab << endl;
//   vocab.save("vocab_sift.yml.gz");
//   cout << "done" << endl;

//   return 0;
// }

int main(int argc, char** argv)
{
  // read the images and database
  cout << "reading database" << endl;
  DBoW3::Vocabulary vocab("./vocab_sift.yml.gz");
  // DBoW3::Vocabulary vocab("./vocabulary.yml.gz");
  // DBoW3::Vocabulary vocab("./vocab_larger.yml.gz");  // use large vocab if you want:
  if (vocab.empty())
  {
    cerr << "Vocabulary does not exist." << endl;
    return 1;
  }
  cout << "reading images... " << endl;
  vector<pcl::PointCloud<pcl::PointXYZRGB>::Ptr> pcs;
  vector<Mat> images, depths;
  readConfig();
  readData(pcs, images, depths);

  // NOTE: in this case we are comparing images with a vocabulary generated by themselves, this may lead to overfit.
  cout << "detecting features ... " << endl;
  // Ptr<Feature2D> detector = ORB::create();
  Ptr<SIFT> detector = SIFT::create(1000);
  vector<Mat> descriptors;
  for (Mat& image : images)
  {
    vector<KeyPoint> keypoints;
    Mat descriptor;
    detector->detectAndCompute(image, Mat(), keypoints, descriptor);
    descriptors.push_back(descriptor);
  }

  // we can compare the images directly or we can compare one image to a database
  // images :
  cout << "comparing images with images " << endl;
  for (int i = 0; i < images.size(); i++)
  {
    DBoW3::BowVector v1;
    vocab.transform(descriptors[i], v1);
    for (int j = i; j < images.size(); j++)
    {
      DBoW3::BowVector v2;
      vocab.transform(descriptors[j], v2);
      double score = vocab.score(v1, v2);
      cout << "image " << i << " vs image " << j << " : " << score << endl;
    }
    cout << endl;
  }

  // or with database
  cout << "comparing images with database " << endl;
  DBoW3::Database db(vocab, false, 0);
  for (int i = 0; i < descriptors.size(); i++)
    db.add(descriptors[i]);
  cout << "database info: " << db << endl;
  for (int i = 0; i < descriptors.size(); i++)
  {
    DBoW3::QueryResults ret;
    db.query(descriptors[i], ret, 4);  // max result=4
    cout << "searching for image " << i << " returns " << ret << endl << endl;
  }
  cout << "done." << endl;
}